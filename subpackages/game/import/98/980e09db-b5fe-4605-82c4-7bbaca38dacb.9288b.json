[1,0,0,[["cc.TextAsset",["_name","text"],1]],[[0,0,1,3]],[[0,"pako_inflate.min.d","export = Pako;\nexport as namespace pako;\n\ndeclare namespace Pako {\n    enum constants {\n        // FlushValues\n        Z_NO_FLUSH = 0,\n        Z_PARTIAL_FLUSH = 1,\n        Z_SYNC_FLUSH = 2,\n        Z_FULL_FLUSH = 3,\n        Z_FINISH = 4,\n        Z_BLOCK = 5,\n        Z_TREES = 6,\n        // StrategyValues\n        Z_FILTERED = 1,\n        Z_HUFFMAN_ONLY = 2,\n        Z_RLE = 3,\n        Z_FIXED = 4,\n        Z_DEFAULT_STRATEGY = 0,\n        // ReturnCodes\n        Z_OK = 0,\n        Z_STREAM_END = 1,\n        Z_NEED_DICT = 2,\n        Z_ERRNO = -1,\n        Z_STREAM_ERROR = -2,\n        Z_DATA_ERROR = -3,\n        Z_BUF_ERROR = -5,\n    }\n\n    type FlushValues =\n        | constants.Z_NO_FLUSH\n        | constants.Z_PARTIAL_FLUSH\n        | constants.Z_SYNC_FLUSH\n        | constants.Z_FINISH\n        | constants.Z_BLOCK\n        | constants.Z_TREES;\n\n    type StrategyValues =\n        | constants.Z_FILTERED\n        | constants.Z_HUFFMAN_ONLY\n        | constants.Z_RLE\n        | constants.Z_FIXED\n        | constants.Z_DEFAULT_STRATEGY;\n\n    type ReturnCodes =\n        | constants.Z_OK\n        | constants.Z_STREAM_END\n        | constants.Z_NEED_DICT\n        | constants.Z_ERRNO\n        | constants.Z_STREAM_ERROR\n        | constants.Z_DATA_ERROR\n        | constants.Z_BUF_ERROR\n        | constants.Z_DEFAULT_STRATEGY;\n\n    interface DeflateOptions {\n        level?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;\n        windowBits?: number | undefined;\n        memLevel?: number | undefined;\n        strategy?: StrategyValues | undefined;\n        dictionary?: any;\n        raw?: boolean | undefined;\n        chunkSize?: number | undefined;\n        gzip?: boolean | undefined;\n        header?: Header | undefined;\n    }\n\n    interface DeflateFunctionOptions {\n        level?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | undefined;\n        windowBits?: number | undefined;\n        memLevel?: number | undefined;\n        strategy?: StrategyValues | undefined;\n        dictionary?: any;\n        raw?: boolean | undefined;\n    }\n\n    interface InflateOptions {\n        windowBits?: number | undefined;\n        dictionary?: any;\n        raw?: boolean | undefined;\n        to?: \"string\" | undefined;\n        chunkSize?: number | undefined;\n    }\n\n    interface InflateFunctionOptions {\n        windowBits?: number | undefined;\n        raw?: boolean | undefined;\n        to?: \"string\" | undefined;\n    }\n\n    interface Header {\n        text?: boolean | undefined;\n        time?: number | undefined;\n        os?: number | undefined;\n        extra?: number[] | undefined;\n        name?: string | undefined;\n        comment?: string | undefined;\n        hcrc?: boolean | undefined;\n    }\n\n    type Data = Uint8Array | ArrayBuffer;\n\n    /**\n     * Compress data with deflate algorithm and options.\n     */\n    function deflate(data: Data | string, options?: DeflateFunctionOptions): Uint8Array;\n\n    /**\n     * The same as deflate, but creates raw data, without wrapper (header and adler32 crc).\n     */\n    function deflateRaw(data: Data | string, options?: DeflateFunctionOptions): Uint8Array;\n\n    /**\n     * The same as deflate, but create gzip wrapper instead of deflate one.\n     */\n    function gzip(data: Data | string, options?: DeflateFunctionOptions): Uint8Array;\n\n    /**\n     * Decompress data with inflate/ungzip and options. Autodetect format via wrapper header\n     * by default. That's why we don't provide separate ungzip method.\n     */\n    function inflate(data: Data, options: InflateFunctionOptions & { to: \"string\" }): string;\n    function inflate(data: Data, options?: InflateFunctionOptions): Uint8Array;\n\n    /**\n     * The same as inflate, but creates raw data, without wrapper (header and adler32 crc).\n     */\n    function inflateRaw(data: Data, options: InflateFunctionOptions & { to: \"string\" }): string;\n    function inflateRaw(data: Data, options?: InflateFunctionOptions): Uint8Array;\n\n    /**\n     * Just shortcut to inflate, because it autodetects format by header.content. Done for convenience.\n     */\n    function ungzip(data: Data, options: InflateFunctionOptions & { to: \"string\" }): string;\n    function ungzip(data: Data, options?: InflateFunctionOptions): Uint8Array;\n\n    // https://github.com/nodeca/pako/blob/893381abcafa10fa2081ce60dae7d4d8e873a658/lib/deflate.js\n    class Deflate {\n        constructor(options?: DeflateOptions);\n        err: ReturnCodes;\n        msg: string;\n        result: Uint8Array;\n        onData(chunk: Data): void;\n        onEnd(status: number): void;\n        push(data: Data | string, mode?: FlushValues | boolean): boolean;\n    }\n\n    // https://github.com/nodeca/pako/blob/893381abcafa10fa2081ce60dae7d4d8e873a658/lib/inflate.js\n    class Inflate {\n        constructor(options?: InflateOptions);\n        header?: Header | undefined;\n        err: ReturnCodes;\n        msg: string;\n        result: Uint8Array | string;\n        onData(chunk: Data): void;\n        onEnd(status: number): void;\n        push(data: Data, mode?: FlushValues | boolean): boolean;\n    }\n}\n"]],0,0,[],[],[]]